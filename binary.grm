Zero = "0";
One = "1";
Bit = Zero | One;
Unit = (Zero) | (One One One+);
Even = One One;
Odd = One Even*;
export First = Optimize[Zero Zero* Bit* One One One One?];
export Second = Optimize[Zero Bit* One One One];
export Disagreements = Optimize[(First-Second)|(Second-First)];
export Triplets = Optimize[Unit+];
export NotPillars = Optimize[Bit*-Even*];
export Oddlets = Optimize[Zero* (Odd Zero+)* Odd?];
export WFlip = Optimize[(((Zero:One)|(One:Zero) <2>)|(Bit <1>))((Zero:Zero One <0.5>)|(One:Zero <0.4>))*(Bit <0.5>)]; 
export WeightedMultipath = (Zero:One <0.3>)|(Zero:One <1>);
export WeightedMultipathOpt = Optimize[WeightedMultipath];
export T_out = Project[ WeightedMultipath, 'output']; # erases input from T(input 1 output 1)
export xT_out = Project[ Zero @ WeightedMultipath, 'output']; # erases input x from x @ T(input 1 output 1)
export Ty_in = Project[ WeightedMultipath @ One, 'input']; # erases output y from T @ y(input 0 output 0)
export xTy = Zero @ WeightedMultipath @ One; (input 0 output 1)
export exTye = ("":Zero) @ WeightedMultipath @ (One:""); # erases input x & output y from x @ T @ y (invalid)
export xT_out_opt = Optimize[xT_out];
export Ty_in_opt = Optimize[Ty_in];
export exTye_opt = Optimize[exTye];